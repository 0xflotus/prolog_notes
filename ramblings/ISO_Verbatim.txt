From p.61 ff. of ISO/IEC 13211-1, 1st edition 1995-06-01

### 7.12 Errors 

An error is a special circumstance which causes the normal process of execution to be interrupted.

The error conditions for each control construct and built.in predicate are specified in the clauses defining them.

Other error conditions are defined in this part of ISO/IEC 13211 where it states: "It shall be an error if ...". 

When more than one error condition is satisfied, the error that is reported by the Prolog processor is implementation-dependent.

NOTE - Errors may also occur if:

a) There is an attempt to execute a goal for which there is no procedure (see 7.7.7 b, 7.11.2.4).

b) The processor is too small, or execution requires too many resources (see 7.12.2 h).

c) Execution cannot be completed because of some event outside the Prolog processor, for example a disc crash or interrupt (see 7.12.2 j).

d) The value of an evaluable functor is one of the exceptional values (9.1.2). [9.1.2: Exceptional values -- An exceptional value is float_overflow, int_overflow, underflow, zero_divisor or undefined. NOTE - It is an evaluation_error(E) if the value of an expression is an exceptional value (see 7.9.2)]

#### 7.12.1 The effect of an error

When an error occurs, the current goal shall be replaced by a goal "throw(error(Error_term, Imp_def))" where:

"Error_term" - is a term that supplies information about an error, and

"Imp_def" - is an impementation-defined term.

NOTE - This part of ISO/IEC 13211 defines features for continuing execution in a manner specified by the user, see the control construct "catch/3" (7.8.9).

NOTE: Most errors defined in this part of ISO/IEC 13211 occur because the arguments of the goal fail to satisfy a particular condition; they are thus detected before execution of the goal begins, and no side effect will have taken place. The exceptional cases are: Syntax Errors, Resource Errros, and System Errors.

#### 7.12.2 Error classification

Errors are classified according to the form of "Error_term":

a) There shall be an *Instantiation Error* when an argument or one of its components is a variable, and an instantiated argument or component is required. It has the form "instantiation_error". [In effect, "I need more data", ed.]

b) There shall be a *Type Error* when the type of an argument or one of its components is incorrect, but not a variable. It has the form "type_error(ValidType,Culprit)" where

"ValidType ∈ {atom, atomic, byte, callable, character, compound, evaluable, in_byte, in_character, integer, list, number, predicate_indicator, variable }."

and "Culprit" is the argument or one of its components which causes the error.

NOTE: A Type Error occurs when a value does not belong to one of the types defined in this part of IOS/IEC 13211 and a Domain Error occurs when the value is not a a member of an implementation defined or implementatoin dependent set.

... NON-ISO-NOTE-BY-EDITOR: The "list" is the odd man out in the above, because "list" is not a type but a convention on how a term is supposed to look like non-locally. It would make more sense to generate a "Domain Error" if an argument turns out to not be a list. Especially as there is already a "non_empty_list" Domain Error.

c) There shall be a *Domain Error* when the type of an argument is correct but the value is outside the domain for which the procedure is defined. It has the form "domain_error(ValidDomain, Culprit)" where

"ValidDomain ∈ {character_code_list, close_option, flag_value, io_mode, non_empty_list, not_less_than_zero. operator_priority, operator_specifier, prolog_flag, read_option, source_sink, stream, stream_option, stream_or_alias, stream_position, stream_property, write_option}."

and "Culprit" is the argument or one of its components which causes the error.

d) There shall be an *Existence Error* when the object on which an operation is to be performed does not exist. It has the form "existence_error(ObjectType, Culprit)" where

"ObjectType ∈ {procedure, source_sink, stream}"

and "Culprit" is the argument or one of its components which causes the error.
 
e) There shall be a *Permission Error* when it is not permitted to perform a specific operation. It has the form "permission_error(Operation, PermissionType, Culprit)" where

"Operation ∈ {access, create, input, modify, open, output, reposition}"

and

"PermissionType ∈ {binary_stream, flag, operator, past_end_of_stream, private_procedure, static_procedure, source_sink, stream, text_stream}"

and "Culprit" is the argument or one of its components which causes the error.

f) There shall be a *Representation Error* when an implementatin defined limit has been breached. It has the form "representation_error(Flag)" where 

"Flag ∈ {character, character_code, in_character_code, max_arity, max_integer, min_integer}"

g) There shall be an *Evaluation Error* when the operands (3.121) of an evaluable functor are such that the operation has an exceptional value (9.1.2). It has the form "evaluation_error(Error)" where

"Error ∈ {float_overflow, int_overflow, undefined, underflow, zero_divisor}"

h) There shall be a *Resource Error* at any stage of execution when the processor has insufficient resources to complete execution. It has the form "resource_error(Resource)" where "Resource" is an implementation-dependent atom.

NOTE: A Resource Error may happen for example when a calculation on unbounded integers has a value which is too large.

i) There shall be a *Syntax Error* when a sequence of characters which are being input as a read-term do not conform to the syntax. It has the form "syntax_error(imp_dep_atom)" where "imp_dep_atom" denotes an implementation-dependent atom.

j) There may be a *System Error* at any stage of execution. The conditions in which there shall be a system error, and the action taken by a processor after a system error are implementation dependent. It has the form "system_error".

NOTE: A System Error may happen for example (a) in interactions with the operating system (for example, a disc crash or interrupt), or (b) when a goal "throw(T)" has bene executed and there is no active goal "catch/3".
